import {
  require_hoist_non_react_statics_cjs
} from "./chunk-AV4WJYE4.js";
import "./chunk-UAAIKFTN.js";
import {
  Cookies
} from "./chunk-Z7IJQTBW.js";
import {
  require_react
} from "./chunk-REO7MX2I.js";
import {
  __toESM
} from "./chunk-3TEUGPMP.js";

// node_modules/react-cookie/esm/index.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs(), 1);
var CookiesContext = React.createContext(new Cookies());
var { Provider, Consumer } = CookiesContext;
var CookiesProvider = class extends React.Component {
  constructor(props) {
    super(props);
    if (props.cookies) {
      this.cookies = props.cookies;
    } else {
      this.cookies = new Cookies(void 0, props.defaultSetOptions);
    }
  }
  render() {
    return React.createElement(Provider, { value: this.cookies }, this.props.children);
  }
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function withCookies(WrappedComponent) {
  const name = WrappedComponent.displayName || WrappedComponent.name;
  class CookieWrapper extends React.Component {
    constructor() {
      super(...arguments);
      this.onChange = () => {
        this.forceUpdate();
      };
    }
    listen() {
      this.props.cookies.addChangeListener(this.onChange);
    }
    unlisten(cookies) {
      (cookies || this.props.cookies).removeChangeListener(this.onChange);
    }
    componentDidMount() {
      this.listen();
    }
    componentDidUpdate(prevProps) {
      if (prevProps.cookies !== this.props.cookies) {
        this.unlisten(prevProps.cookies);
        this.listen();
      }
    }
    componentWillUnmount() {
      this.unlisten();
    }
    render() {
      const _a = this.props, { forwardedRef, cookies } = _a, restProps = __rest(_a, ["forwardedRef", "cookies"]);
      const allCookies = cookies.getAll();
      return React.createElement(WrappedComponent, Object.assign({}, restProps, { ref: forwardedRef, cookies, allCookies }));
    }
  }
  CookieWrapper.displayName = `withCookies(${name})`;
  CookieWrapper.WrappedComponent = WrappedComponent;
  const ForwardedComponent = React.forwardRef((props, ref) => {
    return React.createElement(Consumer, null, (cookies) => React.createElement(CookieWrapper, Object.assign({ cookies }, props, { forwardedRef: ref })));
  });
  ForwardedComponent.displayName = CookieWrapper.displayName;
  ForwardedComponent.WrappedComponent = CookieWrapper.WrappedComponent;
  return (0, import_hoist_non_react_statics.default)(ForwardedComponent, WrappedComponent);
}
function isInBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
}
function useCookies(dependencies) {
  const cookies = (0, import_react.useContext)(CookiesContext);
  if (!cookies) {
    throw new Error("Missing <CookiesProvider>");
  }
  const [allCookies, setCookies] = (0, import_react.useState)(() => cookies.getAll());
  if (isInBrowser()) {
    (0, import_react.useLayoutEffect)(() => {
      function onChange() {
        const newCookies = cookies.getAll({
          doNotUpdate: true
        });
        if (shouldUpdate(dependencies || null, newCookies, allCookies)) {
          setCookies(newCookies);
        }
      }
      cookies.addChangeListener(onChange);
      return () => {
        cookies.removeChangeListener(onChange);
      };
    }, [cookies, allCookies]);
  }
  const setCookie = (0, import_react.useMemo)(() => cookies.set.bind(cookies), [cookies]);
  const removeCookie = (0, import_react.useMemo)(() => cookies.remove.bind(cookies), [cookies]);
  const updateCookies = (0, import_react.useMemo)(() => cookies.update.bind(cookies), [cookies]);
  return [allCookies, setCookie, removeCookie, updateCookies];
}
function shouldUpdate(dependencies, newCookies, oldCookies) {
  if (!dependencies) {
    return true;
  }
  for (let dependency of dependencies) {
    if (newCookies[dependency] !== oldCookies[dependency]) {
      return true;
    }
  }
  return false;
}
export {
  Cookies,
  CookiesProvider,
  useCookies,
  withCookies
};
//# sourceMappingURL=react-cookie.js.map
